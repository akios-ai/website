---
title: EnforceCore — Troubleshooting & FAQ
keywords: enforcecore troubleshooting FAQ errors debugging common issues fix help
---

# Troubleshooting & FAQ

---

## Common Errors

### `InvalidToolNameError: Tool name contains invalid characters`

The tool name contains characters outside the allowed set: `[a-zA-Z0-9_.\-:<>]`.

**Fix:** Pass a valid `tool_name` explicitly:
```python
enforcer.enforce_sync(my_func, arg, tool_name="my_tool")
```

### `InputTooLargeError: Input size exceeds limit`

Combined string/bytes arguments exceed 10 MB (default).

**Fix:** Reduce input size, or increase the limit:
```python
from enforcecore import check_input_size
check_input_size(args, kwargs, max_bytes=50 * 1024 * 1024)  # 50 MB
```

### `EnforcementDepthError: Nesting depth exceeds maximum`

An enforced tool called another enforced tool, exceeding the max depth of 10.

**Fix:** Check for recursive chains. The error includes the call chain for debugging.

### `ToolDeniedError: Tool not in allowed list`

The policy does not allow the tool being called.

**Fix:** Add the tool name to `allowed_tools` in your policy:
```yaml
rules:
  allowed_tools:
    - "your_tool_name"  # Add this
```

### `CostLimitError: Cumulative cost exceeds budget`

Total recorded cost exceeded the budget in `resource_limits.max_cost_usd`.

**Fix:** Increase the budget, or reset the tracker:
```python
enforcer.guard.cost_tracker.reset()
```

### `ResourceLimitError: Call duration exceeded`

Tool call exceeded `resource_limits.max_call_duration_seconds`.

**Fix:** Increase the time limit or optimize the tool.

### `PolicyLoadError: No policy provided`

`@enforce` was used without a policy and no default is configured.

**Fix:** Pass a policy, or set an env var:
```bash
ENFORCECORE_DEFAULT_POLICY=policies/default.yaml
```

### `RateLimitError: Rate limit exceeded`

Too many calls in the configured time window — either global RPM or per-tool limit.

**Fix:** Increase the rate limit in your policy:
```yaml
rules:
  rate_limits:
    global_rpm: 120        # Increase from default
    per_tool:
      search_web: 60       # Per-tool override
```

### `ContentViolationError: Content rule violated`

Tool arguments or output matched a dangerous content pattern (shell injection, path traversal, SQL injection, or code execution).

**Fix:** Review the flagged content. If it's a false positive, you can disable specific rule categories:
```yaml
rules:
  content_rules:
    enabled: true
    categories: [shell_injection, sql_injection]  # Only these two
```

### `DomainDeniedError: Domain not allowed`

The tool attempted to access a domain not in the allow list or explicitly in the deny list.

**Fix:** Add the domain to your policy's network allow list:
```yaml
rules:
  network:
    allowed_domains: ["api.example.com", "cdn.example.com"]
```

### `PolicyEvaluationError: Error during rule evaluation`

A rule in the policy failed to evaluate — often due to malformed conditions or missing fields.

**Fix:** Validate your policy with the CLI:
```bash
enforcecore validate --policy policy.yaml
```

### `RuntimeWarning: fail_open is enabled without ENFORCECORE_DEV_MODE=1`

`fail_open=True` is set but you're not in dev mode.

**Fix:** Either disable `fail_open` (recommended) or acknowledge dev mode:
```bash
ENFORCECORE_FAIL_OPEN=false          # Production
ENFORCECORE_DEV_MODE=1               # Development only
```

---

## Debugging Tips

### Enable debug logging

```bash
ENFORCECORE_LOG_LEVEL=DEBUG
```

Shows every enforcement decision, redaction event, and audit entry.

### Check enforcement scope

```python
from enforcecore import get_enforcement_depth, get_enforcement_chain
print(f"Depth: {get_enforcement_depth()}")
print(f"Chain: {get_enforcement_chain()}")
```

### Verify audit trail integrity

```python
from enforcecore import verify_trail
result = verify_trail("audit.jsonl")
if not result.is_valid:
    for error in result.errors:
        print(f"  ERROR: {error}")
```

### Test your policy

```python
from enforcecore.eval import ScenarioRunner
from enforcecore.core.policy import Policy

policy = Policy.from_file("policy.yaml")
runner = ScenarioRunner(policy)
suite = runner.run_all()
print(f"Containment: {suite.containment_rate:.0%}")
```

### Use the CLI

EnforceCore includes 6 CLI commands for debugging and inspection:

```bash
# Show installed version and configuration
enforcecore info

# Validate a policy file
enforcecore validate --policy policy.yaml

# Verify an audit trail
enforcecore verify --trail audit.jsonl

# Run evaluation scenarios
enforcecore eval --scenarios all

# Dry-run a policy without executing tools
enforcecore dry-run --policy policy.yaml --scenarios all

# Inspect effective policy rules
enforcecore inspect --policy policy.yaml
```

---

## FAQ

### What is EnforceCore?

A runtime enforcement layer for AI agents. It intercepts tool/API calls at the code boundary and applies policy-driven rules — blocking denied calls, redacting PII, enforcing resource limits, and recording tamper-proof audit trails.

### How is this different from prompt guardrails?

Prompt guardrails *ask* the model to behave — they can be jailbroken. EnforceCore operates at the **runtime call boundary** — code-level enforcement that cannot be bypassed.

### Does EnforceCore work with my framework?

Yes. Works with **any** Python agent system: plain Python (`@enforce()`), LangGraph, CrewAI, AutoGen — all via `@enforced_tool()` adapters. No hard framework dependency.

### What does "fail-closed" mean?

If anything goes wrong during enforcement, the call is **blocked** — never allowed through. This is the safe default.

### Does it protect against unicode PII evasion?

Yes. Since v1.0.6: NFC normalization, zero-width character stripping, homoglyph detection (~40 confusables), and URL/HTML entity decoding. All automatic before PII pattern matching.

### What PII categories are supported?

| Category | Example | Placeholder |
|---|---|---|
| `email` | `john@example.com` | `<EMAIL>` |
| `phone` | `(555) 123-4567` | `<PHONE>` |
| `ssn` | `123-45-6789` | `<SSN>` |
| `credit_card` | `4111-1111-1111-1111` | `<CREDIT_CARD>` |
| `ip_address` | `192.168.1.100` | `<IP_ADDRESS>` |

### Why regex instead of spaCy/Presidio?

Presidio requires spaCy + Pydantic v1, incompatible with Python 3.14. Regex is zero-dep, portable, and ~0.1–0.5ms per call.

### What's the enforcement overhead?

Benchmarked on Python 3.13 with 1,000 iterations:

| Component | P50 (ms) | P99 (ms) |
|---|---|---|
| Policy evaluation | 0.012 | 0.228 |
| PII redaction (short) | 0.028 | 0.275 |
| Secret detection | 0.012 | 0.017 |
| Content rules | 0.008 | 0.045 |
| Rate limiter | < 0.001 | 0.002 |
| Audit entry | 0.068 | 0.232 |
| **Full E2E** | **0.056** | **0.892** |

Negligible compared to tool call latency (100ms–10s).

### What secrets does EnforceCore detect?

The built-in secret scanner covers 11 categories: AWS access keys, AWS secret keys, GitHub tokens, Google Cloud API keys, Azure connection strings, database URIs, SSH private keys, generic API keys, JWT tokens, Slack tokens, and Stripe keys. You can add custom patterns via `PatternRegistry`.

### What are content rules?

Content rules detect dangerous patterns in tool arguments and outputs — shell injection (`rm -rf`, `; cat /etc/passwd`), path traversal (`../../../`), SQL injection (`' OR 1=1`), and code execution (`eval()`, `exec()`). They fire before the tool runs, preventing the attack.

### How do lifecycle hooks work?

Hooks let you extend the enforcement pipeline without modifying core code:

```python
from enforcecore import on_violation, on_post_call

@on_violation
def alert_on_block(event):
    slack.send(f"Blocked: {event.tool_name} - {event.reason}")

@on_post_call
def log_latency(event):
    metrics.record(event.tool_name, event.duration_ms)
```

Four hook points: `@on_pre_call`, `@on_post_call`, `@on_violation`, `@on_redaction`.

### What happened to guard_sync() and guard_async()?

Removed in v1.0.16a1. Use `Enforcer.from_file()` factory or `@enforce()` decorator instead. See the [API Reference](/enforcecore/api-reference) for migration details.

### How does the Merkle chain work?

Each audit entry contains the SHA-256 hash of the preceding entry. Any modification, deletion, insertion, or reordering is detectable by `verify_trail()`.

### Can I resume the chain across sessions?

Yes. The auditor reads the last entry's hash from an existing trail file and continues the chain seamlessly.

---

## Platform Notes

| Feature | Linux | macOS | Windows |
|---|---|---|---|
| Time limits | ✓ | ✓ | ✓ |
| Memory limits | ✓ (RLIMIT_AS) | ~ (advisory) | ✗ |
| Cost tracking | ✓ | ✓ | ✓ |
| KillSwitch | ✓ | ✓ | ✓ |

---

## Environment Variables

| Variable | Default | Description |
|---|---|---|
| `ENFORCECORE_DEFAULT_POLICY` | `None` | Default policy path |
| `ENFORCECORE_AUDIT_PATH` | `./audit_logs/` | Audit directory |
| `ENFORCECORE_AUDIT_ENABLED` | `true` | Enable auditing |
| `ENFORCECORE_AUDIT_BACKEND` | `jsonl` | Audit backend (`jsonl`, `null`, `callback`, `multi`) |
| `ENFORCECORE_AUDIT_MAX_BYTES` | `10485760` | Max audit file size before rotation (10 MB) |
| `ENFORCECORE_AUDIT_MAX_FILES` | `5` | Max rotated audit files to keep |
| `ENFORCECORE_REDACTION_ENABLED` | `true` | Enable PII redaction |
| `ENFORCECORE_SECRET_SCANNING` | `true` | Enable secret detection |
| `ENFORCECORE_CONTENT_RULES` | `true` | Enable content rule checking |
| `ENFORCECORE_LOG_LEVEL` | `INFO` | Log level |
| `ENFORCECORE_COST_BUDGET_USD` | `100.0` | Global cost budget |
| `ENFORCECORE_RATE_LIMIT_RPM` | `0` | Global rate limit (0 = disabled) |
| `ENFORCECORE_FAIL_OPEN` | `false` | Allow bypass on errors |
| `ENFORCECORE_DEV_MODE` | `false` | Dev mode flag |
| `ENFORCECORE_OTEL_ENABLED` | `false` | Enable OpenTelemetry metrics/tracing |
| `ENFORCECORE_WEBHOOK_URL` | `None` | Webhook endpoint for events |
